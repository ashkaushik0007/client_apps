"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
require("rxjs/Rx");
var GenericTableComponent = (function () {
    function GenericTableComponent(renderer) {
        var _this = this;
        this.renderer = renderer;
        this.columnWidth = {};
        this.sortOrder = [];
        this.metaInfo = {};
        this.selectedRows = [];
        this.openRows = [];
        this._gtSettings = [];
        this._gtFields = [];
        this.gtDefaultTexts = {
            loading: 'Loading...',
            noData: 'No data',
            noMatchingData: 'No data matching results found',
            noVisibleColumnsHeading: 'No visible columns',
            noVisibleColumns: 'Please select at least one column to be visible.',
            tableInfo: 'Showing #recordFrom to #recordTo of #recordsAfterSearch entries.',
            tableInfoAfterSearch: 'Showing  #recordFrom to #recordTo of #recordsAfterSearch entries (filtered from a total of #recordsAll entries).',
            csvDownload: 'download',
            sortLabel: 'Sort:',
            paginateNext: 'Next page',
            paginatePrevious: 'Previous page',
            inlineEditEdited: 'Press enter to save'
        };
        this.gtTexts = this.gtDefaultTexts;
        this.gtEvent = new core_1.EventEmitter();
        this.gtDefaultOptions = {
            csvDelimiter: ';',
            stack: false,
            lazyLoad: false,
            cache: false,
            debounceTime: 200,
            highlightSearch: false,
            rowSelection: false,
            rowSelectionAllowMultiple: true,
            rowExpandAllowMultiple: true,
            numberOfRows: 10,
            reportColumnWidth: false
        };
        this._gtOptions = this.gtDefaultOptions;
        this.store = [];
        this.loading = true;
        this.debounceTimer = null;
        this.gtInfo = {
            pageCurrent: 1,
            pageTotal: 0,
            recordFrom: 0,
            recordTo: 0,
            recordLength: this.gtOptions.numberOfRows,
            recordsAll: 0,
            recordsAfterFilter: 0,
            recordsAfterSearch: 0
        };
        this.refreshPipe = false;
        this.refreshTotals = false;
        this.refreshSorting = false;
        this.editedRows = {};
        this.data = { exportData: [] }; // Store filtered data for export
        /**
         * Sort table by object key.
         * @param {string} objectKey - name of key to sort on.
         * @param {any} event - such as key press during sorting.
         */
        this.gtSort = function (objectKey, event) {
            this.inlineEditCancel(); // cancel inline editing
            // loop through current settings
            for (var i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    // check if sorting is disabled...
                    if (this._gtSettings[i].sort && this._gtSettings[i].sort.indexOf('disable') !== -1) {
                        // ...if so, exit function without applying any sorting
                        return;
                    }
                    else if (typeof this._gtSettings[i].sort === 'undefined') {
                        // ...is so, set sorting property to enable
                        this._gtSettings[i].sort = 'enable';
                    }
                }
            }
            // check length
            var ctrlKey = event.metaKey || event.ctrlKey;
            var sort = this.sortOrder.slice(0);
            var match = -1;
            var matchDesc = -1;
            var pos = -1;
            // check if property already exits
            for (var i = 0; i < sort.length; i++) {
                var hit = sort[i].indexOf(objectKey);
                if (hit !== -1) {
                    match = this.sortOrder.indexOf(objectKey);
                    matchDesc = match === -1 ? this.sortOrder.indexOf('-' + objectKey) : match;
                    pos = Math.max(match, matchDesc);
                }
            }
            // if ctrl key or meta key is press together with sort...
            if (ctrlKey) {
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...add property to sorting
                        this.sortOrder.push(objectKey);
                        break;
                    default:
                        // ...and property is sorted before...
                        if (match !== -1) {
                            // ...change from asc to desc if sorted asc
                            this.sortOrder[pos] = '-' + objectKey;
                        }
                        else if (this.sortOrder.length > 1) {
                            // ...remove sorting if sorted desc
                            this.sortOrder.splice(pos, 1);
                        }
                        else if (this.sortOrder.length === 1) {
                            // ...set sorting to asc if only sorted property
                            this.sortOrder[pos] = objectKey;
                        }
                        break;
                }
            } /* if ctrl key or meta key is not press together with sort... */
            else {
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...sort by property
                        this.sortOrder = [objectKey];
                        break;
                    default:
                        // ...change from desc to asc and vise versa
                        this.sortOrder = match !== -1 ? ['-' + objectKey] : [objectKey];
                        break;
                }
            }
            // update settings object with new sorting information
            for (var i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    switch (this._gtSettings[i].sort) {
                        // if sorted asc...
                        case 'asc':
                            // ...change to desc
                            this._gtSettings[i].sort = 'desc';
                            break;
                        // if sorted desc...
                        case 'desc':
                            // ...change to asc if it's the only sorted property otherwise remove sorting
                            this._gtSettings[i].sort = this.sortOrder.length === 1 && sort.length < 2 ? 'asc' : 'enable';
                            break;
                        // if sorting enabled...
                        case 'enable':
                            // ...change to asc
                            this._gtSettings[i].sort = 'asc';
                            break;
                    }
                    this._gtSettings[i].sortOrder = this._gtSettings[i].sort === 'enable' ? (this._gtSettings.length - 1) : this.sortOrder.indexOf(objectKey) === -1 ? this.sortOrder.indexOf('-' + objectKey) : this.sortOrder.indexOf(objectKey);
                }
                else if (this._gtSettings[i].sort && this._gtSettings[i].sort.indexOf('disable') === -1 && this.sortOrder.indexOf(this._gtSettings[i].objectKey) === -1 && this.sortOrder.indexOf('-' + this._gtSettings[i].objectKey) === -1) {
                    this._gtSettings[i].sort = 'enable';
                    this._gtSettings[i].sortOrder = (this._gtSettings.length - 1);
                }
            }
            // refresh sorting pipe
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            // emit sort event
            this.gtEvent.emit({
                name: 'gt-sorting-applied',
                value: this.sortOrder
            });
        };
        /**
         * Change number of rows to be displayed.
         * @param {string} rowLength - total number of rows.
         * @param {boolean} reset - should page be reset to first page.
         */
        this.changeRowLength = function (rowLength, reset) {
            var lengthValue = isNaN(parseInt(rowLength, 10)) ? 0 : parseInt(rowLength, 10);
            var newPosition = 1;
            if (!lengthValue && this.gtData) {
                lengthValue = this.gtData.length;
            }
            // if reset is not true and we're not lazy loading data...
            if (reset !== true && this._gtOptions.lazyLoad !== true) {
                // ...get current position in record set
                var currentRecord = this.gtInfo.recordLength * (this.gtInfo.pageCurrent - 1);
                var currentPosition = this._gtData.indexOf(this._gtData[currentRecord]) + 1;
                // ...get new position
                newPosition = Math.ceil(currentPosition / lengthValue);
            }
            // change row length
            this.gtInfo.recordLength = lengthValue;
            // go to new position
            this.gtInfo.pageCurrent = newPosition;
            // if lazy loading data...
            if (this._gtOptions.lazyLoad) {
                // ...replace data with place holders for new data
                this._gtData[0] = this.loadingContent(lengthValue);
                // ...empty current store
                this.store = [];
            }
            // this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-row-length-changed',
                value: lengthValue
            });
        };
        /**
         * Force a redraw of table rows.
         * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
         */
        this.redraw = function () {
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            this.refreshPipe = !this.refreshPipe;
        };
        /** Go to next page. */
        this.nextPage = function () {
            var page = this.gtInfo.pageCurrent === this.gtInfo.pageTotal ? this.gtInfo.pageTotal : this.gtInfo.pageCurrent += 1;
            this.goToPage(page);
        };
        /** Go to previous page. */
        this.previousPage = function () {
            var page = this.gtInfo.pageCurrent === 1 ? 1 : this.gtInfo.pageCurrent -= 1;
            this.goToPage(page);
        };
        /** Request more data (used when lazy loading) */
        this.getData = function () {
            // ...emit event requesting for more data
            this.gtEvent.emit({
                name: 'gt-page-changed-lazy',
                value: { pageCurrent: this.gtInfo.pageCurrent, recordLength: this.gtInfo.recordLength }
            });
        };
        /**
         * Go to specific page.
         * @param {number} page - page number.
         */
        this.goToPage = function (page) {
            var _this = this;
            this.gtInfo.pageCurrent = page;
            this.inlineEditCancel(); // cancel inline edit
            // if lazy loading and if page contains no records...
            if (this._gtOptions.lazyLoad) {
                // ...if data for current page contains no entries...
                if (this._gtOptions.cache === false || this._gtData[this.gtInfo.pageCurrent - 1].length === 0) {
                    // ...create temporary content while waiting for data
                    this._gtData[this.gtInfo.pageCurrent - 1] = this.loadingContent(this.gtInfo.recordLength);
                    this.loading = true; // loading true
                }
                // ...if first entry in current page equals our loading placeholder...
                if (this._gtData[this.gtInfo.pageCurrent - 1][0][this.loadingProperty] === this.gtTexts.loading) {
                    // ...get data
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(function () {
                        _this.getData();
                    }, this._gtOptions.debounceTime);
                }
            }
            // this.updateRecordRange();
            // ...emit page change event
            this.gtEvent.emit({
                name: 'gt-page-changed',
                value: { pageCurrent: this.gtInfo.pageCurrent, recordLength: this.gtInfo.recordLength }
            });
        };
        // TODO: move to helper functions
        /** Sort by sort order */
        this.getSortOrder = function (a, b) {
            if (a.sortOrder < b.sortOrder) {
                return -1;
            }
            if (a.sortOrder > b.sortOrder || typeof a.sortOrder === 'undefined') {
                return 1;
            }
            return 0;
        };
        // TODO: move to helper functions
        /** Sort by column order */
        this.getColumnOrder = function (a, b) {
            if (a.columnOrder === undefined) {
                return -1;
            }
            if (a.columnOrder < b.columnOrder) {
                return -1;
            }
            if (a.columnOrder > b.columnOrder) {
                return 1;
            }
            return 0;
        };
        /** Return property */
        this.getProperty = function (array, key) {
            for (var i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
        this.restructureSorting = function () {
            /** Check and store sort order upon initialization.
             *  This is done by checking sort properties in the settings array of the table, if no sorting is defined
             *  we'll sort the data by the first visible and enabled column in the table(ascending). Please note that actually
             *  sorting have to be done server side when lazy loading data for obvious reasons.  */
            // create sorting array
            var sorting = [];
            if (this._gtSettings) {
                // ...sort settings by sort order
                this._gtSettings.sort(this.getSortOrder);
                // ...loop through settings
                for (var i = 0; i < this._gtSettings.length; i++) {
                    var setting = this._gtSettings[i];
                    // ...if sorted ascending...
                    if (setting.sort === 'asc') {
                        // ... add to sorting
                        sorting.push(setting.objectKey);
                    } /* ...else if sorted descending... */
                    else if (setting.sort === 'desc') {
                        // ... add to sorting
                        sorting.push('-' + setting.objectKey);
                    }
                }
                // ...if no sorting applied...
                if (sorting.length === 0) {
                    // ...sort settings by column order
                    this._gtSettings.sort(this.getColumnOrder);
                    // ...loop through settings
                    for (var i = 0; i < this._gtSettings.length; i++) {
                        var setting = this._gtSettings[i];
                        // ...if column is enabled and visible...
                        if (setting.enabled !== false && setting.visible !== false) {
                            // ...add first match and exit function
                            this.sortOrder = [this._gtSettings[i].objectKey];
                            return;
                        }
                    }
                }
            }
            if (this.sortOrder.length === 0) {
                this.sortOrder = sorting;
            }
        };
        /**
         *  Extend object function.
         */
        this.extend = function (a, b) {
            for (var key in b) {
                if (b.hasOwnProperty(key)) {
                    a[key] = b[key];
                }
            }
            return a;
        };
        this.gtEvent.subscribe(function ($event) {
            if ($event.name === 'gt-info') {
                _this.updateRecordRange();
            }
            if ($event.name === 'gt-row-updated') {
                _this.updateTotals();
            }
        });
    }
    Object.defineProperty(GenericTableComponent.prototype, "gtRowComponent", {
        get: function () {
            return this._gtRowComponent;
        },
        set: function (value) {
            console.warn('GtRowComponent has been deprecated and support will be removed in a future release, see https://github.com/hjalmers/angular-generic-table/issues/34');
            this._gtRowComponent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "hasEdits", {
        get: function () {
            return Object.keys(this.editedRows).length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtOptions", {
        get: function () {
            return this._gtOptions;
        },
        set: function (value) {
            this._gtOptions = value;
            // if number of rows is passed and if number of rows differs from current record length...
            if (this.gtOptions.numberOfRows && this.gtInfo.recordLength !== this.gtOptions.numberOfRows) {
                // ...update record length and redraw table
                this.gtInfo.recordLength = this.gtOptions.numberOfRows;
                this.redraw();
            }
            // ...extend gtOptions default values with values passed into component
            this._gtOptions = this.extend(this.gtDefaultOptions, this._gtOptions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtTotals", {
        get: function () {
            return this._gtTotals;
        },
        set: function (value) {
            this._gtTotals = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtFields", {
        get: function () {
            return this._gtFields;
        },
        set: function (value) {
            this._gtFields = value;
            var COLUMNS_WITH_CLASS_NAMES = this._gtFields
                .map(function (column) { return column; })
                .filter(function (column) { return column.classNames; });
            // TODO: remove deprecated warning when setting has been removed
            if (COLUMNS_WITH_CLASS_NAMES.length > 0) {
                console.warn('Field setting "classNames" have been deprecated in favor for "columnClass" and will be removed in the future, please update field settings for column with object key: ' + COLUMNS_WITH_CLASS_NAMES[0].objectKey);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtSettings", {
        get: function () {
            return this._gtSettings;
        },
        set: function (value) {
            this._gtSettings = value;
            // loop through current settings
            for (var i = 0; i < this._gtSettings.length; i++) {
                // set sort enabled/disabled setting
                this._gtSettings[i].sortEnabled = !(this._gtSettings[i].sort && this._gtSettings[i].sort.indexOf('disable') !== -1);
                // check if sorting is undefined...
                if (typeof this._gtSettings[i].sort === 'undefined') {
                    // ...is so, set sorting property to enable
                    this._gtSettings[i].sort = 'enable';
                }
                // check if column order is undefined...
                if (typeof this._gtSettings[i].columnOrder === 'undefined' && this._gtSettings[i].enabled !== false) {
                    // ...is so, set sorting property to enable
                    this._gtSettings[i].columnOrder = this._gtSettings[i - 1] ? this._gtSettings[i - 1].columnOrder + 1 : 0;
                }
            }
            this.restructureSorting();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtData", {
        get: function () {
            return this._gtData;
        },
        set: function (value) {
            this._gtData = value;
        },
        enumerable: true,
        configurable: true
    });
    /** Update record range. */
    GenericTableComponent.prototype.updateRecordRange = function () {
        this.gtInfo.recordFrom = this.gtInfo.recordsAfterSearch === 0 ? 0 : (this.gtInfo.pageCurrent - 1) * this.gtInfo.recordLength + 1;
        this.gtInfo.recordTo = this.gtInfo.recordsAfterSearch < this.gtInfo.pageCurrent * this.gtInfo.recordLength ? this.gtInfo.recordsAfterSearch : this.gtInfo.pageCurrent * this.gtInfo.recordLength;
    };
    ;
    /** Update totals. */
    GenericTableComponent.prototype.updateTotals = function () {
        this.refreshTotals = !this.refreshTotals;
    };
    /**
     * Get meta data for row.
     */
    GenericTableComponent.prototype.getRowState = function (row) {
        return typeof this.metaInfo[row.$$gtRowId] === 'undefined' ? null : this.metaInfo[row.$$gtRowId];
    };
    /**
     * Expand all rows.
     */
    GenericTableComponent.prototype.expandAllRows = function () {
        this._toggleAllRowProperty('isOpen', true);
    };
    /**
     * Collapse all rows.
     */
    GenericTableComponent.prototype.collapseAllRows = function () {
        this._toggleAllRowProperty('isOpen', false);
    };
    /**
     * Select all rows.
     */
    GenericTableComponent.prototype.selectAllRows = function () {
        this._toggleAllRowProperty('isSelected', true);
    };
    /**
     * Deselect all rows.
     */
    GenericTableComponent.prototype.deselectAllRows = function () {
        this._toggleAllRowProperty('isSelected', false);
    };
    /**
     * Toggle row collapsed state ie. expanded/open or collapsed/closed.
     * @param {GtRow} row - row object that should be expanded/collapsed.
     * @param {Type<C>} component - component to render when row is expanded.
     */
    GenericTableComponent.prototype.toggleCollapse = function (row, expandedRow) {
        if (expandedRow) {
            this.expandedRow = expandedRow;
        }
        this._toggleRowProperty(row, 'isOpen');
    };
    /**
     * Toggle row selected state ie. selected or not.
     * @param {GtRow} row - row object that should be selected/deselected.
     */
    GenericTableComponent.prototype.toggleSelect = function (row) {
        this._toggleRowProperty(row, 'isSelected');
    };
    /**
     * Update row data.
     * @param {GtRow} row - row object that has been edited.
     * @param {GtRow} oldValue - row object before edit.
     */
    GenericTableComponent.prototype.updateRow = function (row, oldValue) {
        this._toggleRowProperty(row, 'isUpdated', oldValue);
    };
    /**
     * removes a row from the table
     * @param {any} row - the row object to remove
     */
    GenericTableComponent.prototype.removeRow = function (row) {
        if (this.isRowSelected(row)) {
            this.toggleSelect(row);
        }
        var index = this._gtData.indexOf(row);
        this._gtData.splice(index, 1);
    };
    /**
     * check if a row is selected
     * @param {any} row - row object
     */
    GenericTableComponent.prototype.isRowSelected = function (row) {
        return this.metaInfo[row.$$gtRowId] && this.metaInfo[row.$$gtRowId].isSelected;
    };
    /**
     * Update meta info for all rows, ie. isSelected, isOpen.
     * @param {Array} array - array that holds rows that need to be updated.
     * @param {string} property - name of property that should be changed/toggled.
     * @param {boolean} active - should rows be expanded/open, selected.
     * @param {GtRow} exception - update all rows except this one.
     */
    GenericTableComponent.prototype._updateMetaInfo = function (array, property, active, exception) {
        for (var i = 0; i < array.length; i++) {
            if (!this.metaInfo[array[i].$$gtRowId]) {
                this.metaInfo[array[i].$$gtRowId] = {};
            }
            if (exception && array[i].$$gtRowId === exception.$$gtRowId) {
            }
            else {
                this.metaInfo[array[i].$$gtRowId][property] = active;
            }
        }
    };
    /**
     * Push selected/expanded lazy loaded rows to array with meta data.
     * @param {Array} target - array to which rows should be added.
     * @param {Array} source - array that holds rows that should be added.
     * @returns {Array} array with added rows.
     */
    GenericTableComponent.prototype._pushLazyRows = function (target, source) {
        for (var i = 0; i < source.length; i++) {
            target.push(source[i]);
        }
        return target;
    };
    /**
     * Toggle meta info for all rows, ie. isSelected, isOpen.
     * @param {string} property - name of property that should be changed/toggled.
     * @param {boolean} active - should rows be expanded/open, selected.
     */
    GenericTableComponent.prototype._toggleAllRowProperty = function (property, active) {
        var eventName;
        var eventValue;
        switch (property) {
            case 'isOpen':
                // check if multiple expanded rows are allowed...
                if (this._gtOptions.rowExpandAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowExpandAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'expand-all';
                    this.openRows = this._gtOptions.lazyLoad ? this._pushLazyRows(this.openRows, this._gtData[this.gtInfo.pageCurrent - 1].slice()) : this._gtData.slice();
                    this._updateMetaInfo(this.openRows, property, active);
                }
                else {
                    eventName = 'collapse-all';
                    this._updateMetaInfo(this.openRows, property, active);
                    this.openRows = [];
                }
                eventValue = {
                    expandedRows: this.openRows,
                    changedRow: 'all'
                };
                break;
            case 'isSelected':
                // check if multi row selection is allowed...
                if (this._gtOptions.rowSelectionAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowSelectionAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'select-all';
                    this.selectedRows = this._gtOptions.lazyLoad ? this._pushLazyRows(this.selectedRows, this._gtData[this.gtInfo.pageCurrent - 1].slice()) : this._gtData.slice();
                    this._updateMetaInfo(this.selectedRows, property, active);
                }
                else {
                    eventName = 'deselect-all';
                    this._updateMetaInfo(this.selectedRows, property, active);
                    this.selectedRows = [];
                }
                eventValue = {
                    selectedRows: this.selectedRows,
                    changedRow: 'all'
                };
                break;
        }
        this.gtEvent.emit({
            name: 'gt-row-' + eventName,
            value: eventValue
        });
    };
    /**
     * Toggle meta info for row, ie. isSelected, isOpen.
     * @param {Object} row - row object.
     * @param {string} property - name of property that should be changed/toggled.
     * @param {any} propertyValues - optional property values that can be passed.
     */
    GenericTableComponent.prototype._toggleRowProperty = function (row, property, propertyValues) {
        var eventName;
        var eventValue;
        // make sure gtRowId exists on row object
        if (typeof row.$$gtRowId !== 'undefined') {
            // check if meta info exists for row
            if (!this.metaInfo[row.$$gtRowId]) {
                // if not, add object to store meta info
                this.metaInfo[row.$$gtRowId] = {};
            }
            switch (property) {
                case 'isOpen':
                    var opened = this.metaInfo[row.$$gtRowId][property];
                    // check if multiple expanded rows are allowed...
                    if (this._gtOptions.rowExpandAllowMultiple === false) {
                        // ...if not, collapse all rows except current row
                        this._updateMetaInfo(this.openRows, property, false, row);
                        this.openRows = [];
                    }
                    // check if row is expanded
                    if (!opened) {
                        eventName = 'expand';
                        // add row to expanded rows
                        this.openRows.push(row);
                    }
                    else {
                        eventName = 'collapse';
                        // loop through expanded rows...
                        for (var i = 0; i < this.openRows.length; i++) {
                            // if expanded row equals passed row...
                            if (this.openRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from expanded rows...
                                this.openRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        expandedRows: this.openRows,
                        changedRow: row
                    };
                    break;
                case 'isSelected':
                    var selected = this.metaInfo[row.$$gtRowId][property];
                    // check if multi row selection is allowed...
                    if (this._gtOptions.rowSelectionAllowMultiple === false) {
                        // ...if not, deselect all rows except current row
                        this._updateMetaInfo(this.selectedRows, property, false, row);
                        this.selectedRows = [];
                    }
                    // check if row is selected
                    if (!selected) {
                        eventName = 'select';
                        // add row to selected rows
                        this.selectedRows.push(row);
                    }
                    else {
                        eventName = 'deselect';
                        // loop through selected rows...
                        for (var i = 0; i < this.selectedRows.length; i++) {
                            // if selected row equals passed row...
                            if (this.selectedRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from selected rows...
                                this.selectedRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        selectedRows: this.selectedRows,
                        changedRow: row
                    };
                    break;
                case 'isUpdated':
                    eventName = 'updated';
                    var oldValue = propertyValues;
                    // check if edit object exists for row
                    if (typeof this.metaInfo[row.$$gtRowId][property] === 'undefined') {
                        this.metaInfo[row.$$gtRowId][property] = {
                            originalValue: oldValue,
                            oldValue: oldValue,
                            newValue: row
                        };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId][property].oldValue = oldValue;
                        this.metaInfo[row.$$gtRowId][property].newValue = row;
                    }
                    eventValue = this.metaInfo[row.$$gtRowId][property];
                    break;
            }
            this.gtEvent.emit({
                name: 'gt-row-' + eventName,
                value: eventValue
            });
            if (property !== 'isUpdated') {
                this.metaInfo[row.$$gtRowId][property] = !this.metaInfo[row.$$gtRowId][property];
            }
        }
    };
    /**
     * Update column.
     * @param {Object} $event - key up event.
     * @param {GtRow} row - row object.
     * @param {GtRenderField} column - column object.
     */
    GenericTableComponent.prototype.gtUpdateColumn = function ($event, row, column) {
        this._editRow(row, column);
    };
    /**
     * Dropdown select.
     * @param {GtRow} row - row object.
     * @param {GtRenderField} column - column object.
     */
    GenericTableComponent.prototype.gtDropdownSelect = function (row, column) {
        var oldValue = __assign({}, row);
        row[column.objectKey] = column.renderValue;
        this.updateRow(row, oldValue);
    };
    GenericTableComponent.prototype._editRow = function (row, column) {
        var OBJECT_KEY = column.objectKey; // declare object key which contains changes
        // check if cell has changed value
        column.edited = row[column.objectKey] !== column.renderValue;
        // check if row contains changes...
        if (!this.editedRows[row.$$gtRowId]) {
            // if not, create an object for the changed row
            this.editedRows[row.$$gtRowId] = {
                changes: {},
                row: row // store reference to the row that should be updated
            };
        }
        // store changed column under changes if it has been edited
        if (column.edited) {
            this.editedRows[row.$$gtRowId].changes[OBJECT_KEY] = column;
        }
        else {
            // delete change object if column is unchanged
            delete this.editedRows[row.$$gtRowId].changes[OBJECT_KEY];
            // check how many columns have been changed
            var CHANGED_COLUMNS = Object.keys(this.editedRows[row.$$gtRowId].changes).length;
            if (CHANGED_COLUMNS === 0) {
                // delete row from edited rows if no columns have been edited
                delete this.editedRows[row.$$gtRowId];
            }
        }
        // if no listener is present...
        if (!this.globalInlineEditListener) {
            // ...listen for update event
            this._listenForKeydownEvent();
        }
    };
    /**
     * Listen for key down event - listen for key down event during inline edit.
     */
    GenericTableComponent.prototype._listenForKeydownEvent = function () {
        var _this = this;
        // add global listener for key down events
        this.globalInlineEditListener = this.renderer.listen('document', 'keydown', function ($event) {
            switch ($event.key) {
                case 'Enter':
                    _this.inlineEditUpdate();
                    break;
                case 'Escape':
                    _this.inlineEditCancel();
                    break;
            }
        });
    };
    /**
     * Inline edit update - accept changes and update row values.
     */
    GenericTableComponent.prototype.inlineEditUpdate = function () {
        var _this = this;
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(function (key) {
            var ROW = _this.editedRows[key].row; // row to update
            var CHANGES = _this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(function (objectKey) {
                var oldValue = __assign({}, ROW);
                ROW[objectKey] = CHANGES[objectKey].renderValue; // update data value
                _this.updateRow(ROW, oldValue); // update meta info for row and send event
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    };
    /**
     * Inline edit cancel - cancel and reset inline edits.
     */
    GenericTableComponent.prototype.inlineEditCancel = function () {
        var _this = this;
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(function (key) {
            var ROW = _this.editedRows[key].row; // row to update
            var CHANGES = _this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(function (objectKey) {
                CHANGES[objectKey].renderValue = ROW[objectKey]; // reset rendered value
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    };
    /**
     * Stop listening for key down event - stop listening for key down events passed during inline edit.
     */
    GenericTableComponent.prototype._stopListeningForKeydownEvent = function () {
        if (this.globalInlineEditListener) {
            this.globalInlineEditListener();
            this.globalInlineEditListener = null;
        }
    };
    /**
     * Apply filter(s).
     * @param {Object} filter - object containing key value pairs, where value should be array of values.
     */
    GenericTableComponent.prototype.gtApplyFilter = function (filter) {
        this.gtInfo.filter = filter;
        // go to first page
        this.goToPage(1);
        this.updateTotals();
    };
    ;
    /** Clear/remove applied filter(s). */
    GenericTableComponent.prototype.gtClearFilter = function () {
        this.gtInfo.filter = false;
        this.updateTotals();
        // this.updateRecordRange();
    };
    ;
    /**
     * Search
     * @param {string} value - string containing one or more words
     */
    GenericTableComponent.prototype.gtSearch = function (value) {
        this.gtInfo.searchTerms = value;
        // always go to first page when searching
        this.goToPage(1);
        this.updateTotals();
    };
    ;
    /**
     * Create store to hold previously loaded records.
     * @param {number} records - total number of records in store.
     * @param {number} perPage - how many records to show per page.
     * @returns {Array} a nested array to hold records per page.
     */
    GenericTableComponent.prototype.createStore = function (records, perPage) {
        var stores = Math.ceil(records / perPage);
        var store = [];
        for (var i = 0; i < stores; i++) {
            store[i] = [];
        }
        return store;
    };
    ;
    /**
     * Create placeholders for rows while loading data from back-end.
     * @param {number} perPage - how many records to show per page.
     * @returns {Array} an array containing empty records to be presented while fetching real data.
     */
    GenericTableComponent.prototype.loadingContent = function (perPage) {
        // create row object
        var rowObject = {
            $$loading: true
        };
        var order = 0;
        // sort settings by column order
        this._gtSettings.sort(this.getColumnOrder);
        // loop through all settings objects...
        for (var i = 0; i < this._gtSettings.length; i++) {
            var setting = this._gtSettings[i];
            // ...if column is visible and enabled...
            if (setting.visible !== false && setting.enabled !== false) {
                // ...if first column, set value to loading text otherwise leave it empty
                if (order === 0) {
                    rowObject[setting.objectKey] = this.gtTexts.loading;
                    this.loadingProperty = setting.objectKey;
                }
                else {
                    rowObject[setting.objectKey] = '';
                }
                order++;
            }
            else {
                rowObject[setting.objectKey] = '';
            }
        }
        // create content placeholder
        var contentPlaceholder = [];
        // create equal number of rows as rows per page
        for (var i = 0; i < perPage; i++) {
            // ...add temporary row object
            contentPlaceholder.push(rowObject);
        }
        return contentPlaceholder;
    };
    ;
    /** Export data as CSV
     * @param {string} fileName - optional file name (overrides default file name).
     * @param {boolean} useBOM - use BOM (byte order marker).
     */
    GenericTableComponent.prototype.exportCSV = function (fileName, useBOM) {
        var _this = this;
        if (useBOM === void 0) { useBOM = false; }
        var data = this.data.exportData;
        var csv = '';
        var BOM = '\uFEFF';
        // csv export headers
        for (var i = 0; i < this._gtSettings.length; i++) {
            if (this._gtSettings[i].export !== false) {
                csv += this.getProperty(this._gtFields, this._gtSettings[i].objectKey).name;
                if (i < (this._gtSettings.length - 1)) {
                    csv += this._gtOptions.csvDelimiter;
                }
            }
        }
        // csv export body
        data.forEach(function (row) {
            csv += '\n';
            for (var i = 0; i < _this._gtSettings.length; i++) {
                if (_this._gtSettings[i].export !== false) {
                    // get field settings
                    var fieldSetting = _this.getProperty(_this._gtFields, _this._gtSettings[i].objectKey);
                    // get export value, if export function is defined use it otherwise check for value function and as a last resort export raw data
                    var exportValue = fieldSetting.export && typeof fieldSetting.export === 'function' ?
                        fieldSetting.export(row) : fieldSetting.value && typeof fieldSetting.value === 'function' ?
                        fieldSetting.value(row) : row[_this._gtSettings[i].objectKey];
                    // escape export value using double quotes (") if export value contains delimiter
                    exportValue = typeof exportValue === 'string' && exportValue.indexOf(_this._gtOptions.csvDelimiter) !== -1 ? '"' + exportValue + '"' : exportValue;
                    csv += exportValue;
                    if (i < (_this._gtSettings.length - 1)) {
                        csv += _this._gtOptions.csvDelimiter;
                    }
                }
            }
        });
        var blob = new Blob([(useBOM ? BOM : '') + csv], {
            type: 'text/csv;charset=utf-8'
        });
        if (window.navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
        }
        else {
            var link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            if (link.download !== undefined) {
                link.setAttribute('href', 'data:text/csv;charset=utf-8,' + encodeURIComponent((useBOM ? BOM : '') + csv)); //URL.createObjectURL(blob));
                link.setAttribute('download', fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
                document.body.appendChild(link);
                link.click();
            }
            else {
                csv = 'data:text/csv;charset=utf-8,' + (useBOM ? BOM : '') + csv;
                window.open(encodeURIComponent(csv));
            }
            document.body.removeChild(link);
        }
        // emit export event
        this.gtEvent.emit({
            name: 'gt-exported-csv',
            value: fileName ? fileName : this.gtTexts.csvDownload + '.csv'
        });
    };
    GenericTableComponent.prototype.ngOnInit = function () {
        // if number of row to display from start is set to null or 0...
        if (!this.gtOptions.numberOfRows) {
            // ...change row length
            this.changeRowLength(this.gtOptions.numberOfRows);
        }
        this.restructureSorting();
    };
    GenericTableComponent.prototype.ngOnChanges = function (changes) {
        // if gt texts have changed...
        if (changes['gtTexts']) {
            // ...extend gtOptions default values with values passed into component
            this.gtTexts = this.extend(this.gtDefaultTexts, this.gtTexts);
        }
        // if lazy loading data and paging information is available...
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            // ...calculate total number of pages
            this.gtInfo.pageTotal = Math.ceil(this.gtInfo.recordsAfterSearch / this.gtInfo.recordLength);
            // ...declare store position
            var storePosition = this.gtInfo.pageCurrent - 1;
            // ...and if store is empty or page length has changed...
            if (this.store.length === 0 || this.store[0].length !== this.gtInfo.recordLength) {
                // ...create store
                this.store = this.createStore(this.gtInfo.recordsAfterSearch, this.gtInfo.recordLength);
            }
            // ...store retrieved data in store at store position
            this.store[storePosition] = this._gtData;
            // replace data with store
            this._gtData = this.store;
            this.loading = false;
            this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-info',
                value: this.gtInfo
            });
        }
        else if (this._gtData && this._gtData.length >= 0 && changes['gtData'] && changes['gtData'].previousValue) {
            this.loading = false;
        }
        else if (changes['gtData'] && changes['gtData'].firstChange && this._gtData && this._gtData.length > 0) {
            this.loading = false;
        }
    };
    GenericTableComponent.prototype.trackByFn = function (index, item) {
        return item.$$gtRowId;
    };
    GenericTableComponent.prototype.trackByColumnFn = function (index, item) {
        return item.objectKey;
    };
    GenericTableComponent.prototype.ngOnDestroy = function () {
        // remove listener
        this._stopListeningForKeydownEvent();
    };
    return GenericTableComponent;
}());
GenericTableComponent.decorators = [
    { type: core_1.Component, args: [{
                selector: 'generic-table',
                template: "\n        <table class=\"table\" ngClass=\"{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}\"\n               *ngIf=\"gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length > 0\">\n            <thead>\n            <tr>\n                <th class=\"gt-sort-label\" *ngIf=\"gtOptions.stack\">{{gtTexts.sortLabel}}</th>\n                <th *ngFor=\"let column of gtSettings | gtVisible:gtSettings:refreshPipe\"\n                    ngClass=\"{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{column.sortEnabled ? 'sort-'+column.sort:''}} {{column.sortEnabled && column.sortOrder >= 0  ? 'sort-order-'+column.sortOrder:''}} {{ gtFields | gtColumnClass:'th':column }}\"\n                    (click)=\"column.sortEnabled ? gtSort(column.objectKey,$event):'';\">\n                    {{gtFields | gtProperty:column.objectKey:'name'}}\n                </th>\n            </tr>\n            </thead>\n            <ng-template\n                    [ngIf]=\"gtTotals && (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length).length > 0\">\n                <thead class=\"gt-totals\">\n                <tr *ngFor=\"let total of gtTotals | gtTotalsPosition\">\n                    <td *ngFor=\"let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;\"\n                        ngClass=\"{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:'total':column }}\">\n                        <span *ngIf=\"i === 0\" class=\"float-left\">{{total.name}}</span><span\n                            [innerHTML]=\"total.fields[column.objectKey] | gtTotals:total.update === false ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals\"></span>\n                    </td>\n                </tr>\n                </thead>\n                <tfoot class=\"gt-totals\">\n                <tr *ngFor=\"let total of gtTotals | gtTotalsPosition:'footer'\">\n                    <td *ngFor=\"let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;\"\n                        ngClass=\"{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:'total':column }}\">\n                        <span *ngIf=\"i === 0\" class=\"float-left\">{{total.name}}</span><span\n                            [innerHTML]=\"total.fields[column.objectKey] | gtTotals:total.update === false ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals\"></span>\n                    </td>\n                </tr>\n                </tfoot>\n            </ng-template>\n            <tbody *ngIf=\"gtData && gtInfo\">\n            <ng-template class=\"table-rows\" ngFor let-row let-last=\"last\" [ngForTrackBy]=\"trackByFn\"\n                         [ngForOf]=\"gtOptions.lazyLoad && gtInfo ? (gtData[gtInfo.pageCurrent-1] | gtMeta:(gtInfo.pageCurrent-1):gtInfo.recordLength) : (gtData | gtMeta:null:null:gtData.length | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length | gtOrderBy:sortOrder:gtFields:refreshSorting:gtData.length | gtChunk:gtInfo:gtInfo.recordLength:gtInfo.pageCurrent:refreshPageArray:gtData.length:gtEvent:data | gtRowClass:gtFields)\">\n                <tr [ngClass]=\"{'row-selected':metaInfo[row.$$gtRowId]?.isSelected, 'row-open':metaInfo[row.$$gtRowId]?.isOpen, 'row-loading':loading, 'row-expandable':gtRowComponent}\"\n                    class=\"{{row.$$gtRowClass}}\"\n                    (click)=\"gtOptions.rowSelection ? toggleSelect(row):null\">\n                    <td *ngFor=\"let column of row | gtRender:gtSettings:gtFields:refreshPipe:loading:gtOptions.highlightSearch:gtInfo.searchTerms;trackBy:trackByColumnFn\"\n                        ngClass=\"{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{(gtFields | gtProperty:column.objectKey:'inlineEdit') ? 'gt-inline-edit':''}} {{column.edited ? 'gt-edited':''}} {{ gtFields | gtColumnClass:row:column }}\">\n                        <span class=\"gt-row-label\"\n                              *ngIf=\"gtOptions.stack\">{{(gtFields | gtProperty:column.objectKey:'stackedHeading') ? (gtFields | gtProperty:column.objectKey:'stackedHeading') : (gtFields | gtProperty:column.objectKey:'name')}}</span>\n                        <gt-custom-component-factory *ngIf=\"column.columnComponent\" class=\"gt-row-content\"\n                                                     [type]=\"column.columnComponent.type\"\n                                                     [injector]=\"column.columnComponent.injector\" [row]=\"row\"\n                                                     [column]=\"column\" (redrawEvent)=\"redraw($event)\"\n                                                     (click)=\"column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''\"></gt-custom-component-factory>\n                        <span *ngIf=\"!column.columnComponent && !(gtFields | gtProperty:column.objectKey:'inlineEdit')\"\n                              class=\"gt-row-content\" [innerHTML]=\"column.renderValue\"\n                              (click)=\"column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''\"></span>\n                        <ng-template\n                                [ngIf]=\"!column.columnComponent && [true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') !== -1\">\n                            <input class=\"inline-edit\" [attr.type]=\"(gtFields | gtProperty:column.objectKey:'inlineEdit') === true ? 'text':(gtFields | gtProperty:column.objectKey:'inlineEdit')\" [(ngModel)]=\"column.renderValue\"\n                                   (keyup)=\"gtUpdateColumn($event,row, column)\">\n                            <span class=\"gt-inline-edit-notice\">{{gtTexts.inlineEditEdited}}</span>\n                        </ng-template>\n                        <gt-dropdown\n                                *ngIf=\"!column.columnComponent && (gtFields | gtProperty:column.objectKey:'inlineEdit') && [true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') === -1\"\n                                [options]=\"gtFields | gtProperty:column.objectKey:'inlineEdit'\"\n                                [id]=\"'_' + row.$$gtRowId + '_' + column.objectKey\"\n                                [(selected)]=\"column.renderValue\" (selectedChange)=\"gtDropdownSelect(row, column)\">Add\n                            inline editing module\n                        </gt-dropdown>\n                    </td>\n                </tr>\n                <tr class=\"row-expanded\" *ngIf=\"metaInfo[row.$$gtRowId]?.isOpen\">\n                    <td [attr.colspan]=\"(gtFields | gtVisible:gtSettings:refreshPipe).length\">\n                        <gt-expanding-row [row]=\"row\"\n                                          [type]=\"gtRowComponent ? gtRowComponent:expandedRow.component\"\n                                          [columnWidth]=\"columnWidth\"\n                                          [gtFields]=\"gtFields\"\n                                          [gtOptions]=\"gtOptions\"\n                                          [gtInfo]=\"gtInfo\"\n                                          [gtSettings]=\"gtSettings\"\n                                          [data]=\"expandedRow.data\"\n                                          (redrawEvent)=\"redraw($event)\"\n                                          (toggleRowEvent)=\"toggleCollapse($event)\"></gt-expanding-row>\n                    </td>\n                </tr>\n                <tr *ngIf=\"gtOptions.reportColumnWidth && last\">\n                    <td style=\"padding: 0; border:none;\"\n                        *ngFor=\"let column of gtSettings | gtVisible:gtSettings:refreshPipe\" gtColumnWidth\n                        [objectKey]=\"column.objectKey\" [widths]=\"columnWidth\"></td>\n                </tr>\n            </ng-template>\n            <tr *ngIf=\"gtInfo.pageTotal === 0 && (gtInfo.searchTerms || gtInfo.filter) && !loading\">\n                <td class=\"gt-no-matching-results\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">\n                    {{gtTexts.noMatchingData}}\n                </td>\n            </tr>\n            <tr *ngIf=\"gtInfo.pageTotal === 0 && !(gtInfo.searchTerms || gtInfo.filter) && !loading\">\n                <td class=\"gt-no-results\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">{{gtTexts.noData}}\n                </td>\n            </tr>\n            <tr *ngIf=\"gtInfo.pageTotal === 0 && loading\">\n                <td class=\"gt-loading-data\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">{{gtTexts.loading}}</td>\n            </tr>\n            </tbody>\n        </table>\n        <table class=\"table\" ngClass=\"{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}\"\n               *ngIf=\"gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length === 0\">\n            <thead>\n            <tr>\n                <th class=\"gt-no-visible-columns\">{{gtTexts.noVisibleColumnsHeading}}</th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr>\n                <td class=\"gt-no-visible-columns\">{{gtTexts.noVisibleColumns}}</td>\n            </tr>\n            </tbody>\n        </table>\n        <table class=\"table\" ngClass=\"{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}\"\n               *ngIf=\"!gtFields || !gtSettings\">\n            <thead>\n            <tr>\n                <th class=\"gt-loading-config\">&nbsp;</th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr>\n                <td class=\"gt-loading-config\">&nbsp;</td>\n            </tr>\n            </tbody>\n        </table>\n    ",
            },] },
];
/** @nocollapse */
GenericTableComponent.ctorParameters = function () { return [
    { type: core_1.Renderer2, },
]; };
GenericTableComponent.propDecorators = {
    'gtOptions': [{ type: core_1.Input },],
    'gtTotals': [{ type: core_1.Input },],
    'gtFields': [{ type: core_1.Input },],
    'gtSettings': [{ type: core_1.Input },],
    'gtData': [{ type: core_1.Input },],
    'gtRowComponent': [{ type: core_1.Input },],
    'gtTexts': [{ type: core_1.Input },],
    'gtClasses': [{ type: core_1.Input },],
    'gtEvent': [{ type: core_1.Output },],
    'gtInfo': [{ type: core_1.Input },],
};
exports.GenericTableComponent = GenericTableComponent;
//# sourceMappingURL=generic-table.component.js.map